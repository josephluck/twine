(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", { value: true });
function noop() {
    return null;
}
function arrayToObj(curr, prev) {
    return Object.assign({}, curr, prev);
}
function merge(model, prop) {
    if (model.models) {
        var child = Object.keys(model.models).map(function (key) {
            return _defineProperty({}, key, merge(model.models[key], prop));
        }).reduce(arrayToObj, {});
        return Object.assign({}, model[prop], child);
    }
    return model[prop];
}
exports.merge = merge;
function createState(model) {
    return merge(model, 'state');
}
exports.createState = createState;
function retrieveNestedModel(model, path) {
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    if (model.models) {
        var currModel = model.models[path[index]];
        if (currModel && currModel.models && currModel.models[path[index + 1]]) {
            return retrieveNestedModel(currModel, path, index + 1);
        }
        return currModel;
    }
    return model;
}
exports.retrieveNestedModel = retrieveNestedModel;
function getNestedObjFromPath(state, path) {
    if (path.length) {
        return getNestedObjFromPath(state[path[0]], path.slice(1));
    }
    return state;
}
exports.getNestedObjFromPath = getNestedObjFromPath;
function updateStateAtPath(state, path, value) {
    if (path.length > 0) {
        var key = path[0];
        if (path.length > 1) {
            state[key] = updateStateAtPath(state[key], path.slice(1), value);
        } else {
            state[key] = value;
        }
    }
    return state;
}
exports.updateStateAtPath = updateStateAtPath;
function twine(opts) {
    if (!opts) {
        opts = noop;
    }
    var onStateChange = typeof opts === 'function' ? opts : opts.onStateChange || noop;
    var onMethodCall = typeof opts === 'function' ? noop : opts.onMethodCall || noop;
    return function output(model) {
        var state = createState(model);
        var actions = createActions(model, []);
        function decorateActions(reducers, effects, path) {
            var decoratedReducers = Object.keys(reducers || {}).map(function (key) {
                return _defineProperty({}, key, function () {
                    var oldState = Object.assign({}, state);
                    var localState = path.length ? getNestedObjFromPath(state, path) : state;
                    var reducerArgs = [localState].concat(Array.prototype.slice.call(arguments));
                    var reducerResponse = reducers[key].apply(null, reducerArgs);
                    var newLocalState = Object.assign({}, localState, reducerResponse);
                    state = path.length ? updateStateAtPath(state, path, newLocalState) : newLocalState;
                    var onMethodCallArgs = [state, oldState].concat(Array.prototype.slice.call(arguments));
                    onMethodCall.apply(null, onMethodCallArgs);
                    onStateChange(state, oldState, actions);
                    return newLocalState;
                });
            });
            var decoratedEffects = Object.keys(effects || {}).map(function (key) {
                return _defineProperty({}, key, function () {
                    if (path.length) {
                        var nestedModel = retrieveNestedModel(model, path);
                        var effectState = nestedModel.scoped ? getNestedObjFromPath(state, path) : state;
                        var effectActions = nestedModel.scoped ? getNestedObjFromPath(actions, path) : actions;
                        return effects[key].apply(null, [effectState, effectActions].concat(Array.prototype.slice.call(arguments)));
                    }
                    return effects[key].apply(null, [state, actions].concat(Array.prototype.slice.call(arguments)));
                });
            });
            return decoratedReducers.concat(decoratedEffects).reduce(arrayToObj, {});
        }
        function createActions(model, path) {
            if (model.models) {
                var child = Object.keys(model.models).map(function (key) {
                    return _defineProperty({}, key, createActions(model.models[key], path.concat(key)));
                }).reduce(arrayToObj, {});
                return Object.assign({}, decorateActions(model.reducers, model.effects, path), child);
            }
            return decorateActions(model.reducers, model.effects, path);
        }
        return {
            state: state,
            actions: actions
        };
    };
}
exports.default = twine;

},{}]},{},[1]);
